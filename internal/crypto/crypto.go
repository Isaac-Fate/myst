package crypto

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"strings"

	"github.com/pkg/errors"
	"golang.org/x/crypto/pbkdf2"
)

// Reference: https://gist.github.com/tscholl2/dc7dc15dc132ea70a98e8542fefffa28

// The encrypted secret value is a hex string which consists of 3 parts:
//
// 1. ciphertext: ciphertext of the secret value
// 2. salt: randomly generated salt
// 3. iv: initialization vector
//
// The 3 parts are separated by '-':
// <ciphertext>-<salt>-<iv>

const saltLength int = 32
const ivLength int = 12
const secretKeyLength int = 32
const separator string = "-"

func Encrypt(passphrase string, value string) (string, error) {
	// Derive the secret key from the passphrase and generate a random salt
	key, salt := deriveKey(passphrase, nil)

	// Generate an initialization vector
	iv := make([]byte, ivLength)
	rand.Read(iv)

	// Create an AES block cipher
	blockCipher, err := aes.NewCipher(key)

	if err != nil {
		return "", err
	}

	// Wrap the block cipher in GCM mode
	gcmCipher, err := cipher.NewGCM(blockCipher)

	if err != nil {
		return "", err
	}

	// Encrypt the secret value
	ciphertext := gcmCipher.Seal(nil, iv, []byte(value), nil)

	// Create the encrypted value
	encryptedValue := strings.Join(
		[]string{hex.EncodeToString(ciphertext), hex.EncodeToString(salt), hex.EncodeToString(iv)},
		separator,
	)

	return encryptedValue, nil
}

// Decrypts a secret value encrypted with Encrypt.
//
// The encrypted value is a string which consists of 3 parts separated by '-':
// <ciphertext>-<salt>-<iv>
//
// This function returns the decrypted secret value as a string and an error if
// the decryption fails.
func Decrypt(passphrase string, encryptedValue string) (string, error) {
	// Separate the salt, iv, and ciphertext
	parts := strings.Split(encryptedValue, separator)

	if len(parts) != 3 {
		return "", errors.New("invalid encrypted password")
	}

	// Decode into bytes

	ciphertext, err := hex.DecodeString(parts[0])
	if err != nil {
		return "", err
	}

	salt, err := hex.DecodeString(parts[1])
	if err != nil {
		return "", err
	}

	iv, err := hex.DecodeString(parts[2])
	if err != nil {
		return "", err
	}

	// Derive the secret key from the passphrase and salt
	key, _ := deriveKey(passphrase, salt)

	// Create an AES block cipher
	blockCipher, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	// Wrap the block cipher in GCM mode
	gcmCipher, err := cipher.NewGCM(blockCipher)
	if err != nil {
		return "", err
	}

	// Decrypt the secret value
	decryptedValue, err := gcmCipher.Open(nil, iv, ciphertext, nil)
	if err != nil {
		return "", err
	}

	return string(decryptedValue), nil
}

// Takes a passphrase and returns a digested passphrase, which
// is a string composed of two parts separated by '-': <key>-<salt>. The key
// is derived from the passphrase with a randomly generated salt using the
// PBKDF2 algorithm with 100000 iterations, a key length of secretKeyLength
// and SHA-256 as the underlying hash function. The salt is a randomly
// generated byte slice of length saltLength.
func DigestPassphrase(passphrase string) string {
	// Derive a key from the passphrase with a randomly generated salt
	key, salt := deriveKey(passphrase, nil)

	// The digested passphrase is composed of the key and the salt
	digestedPassphrase := strings.Join(
		[]string{hex.EncodeToString(key), hex.EncodeToString(salt)},
		separator,
	)

	return digestedPassphrase
}

// Verifies whether a passphrase matches a digested passphrase.
//
// A digested passphrase is a string which consists of two parts separated by
// a '-' character. The first part is the key derived from the passphrase and
// the second part is the salt used to derive the key.
//
// This function returns true if the passphrase matches the digested passphrase,
// otherwise it returns false.
func VerifyPassphrase(passphrase string, digestedPassphrase string) bool {
	// Separate the salt and key
	parts := strings.Split(digestedPassphrase, separator)

	if len(parts) != 2 {
		return false
	}

	// Get the ground truth groundTruthKey
	groundTruthKey := parts[0]

	// Get the salt
	salt, err := hex.DecodeString(parts[1])
	if err != nil {
		return false
	}

	// Derive a key from the input passphrase and the salt from the ground truth
	key, _ := deriveKey(passphrase, salt)

	// Compare with the ground truth key
	return hex.EncodeToString(key) == groundTruthKey
}

// Derives a secret key from a passphrase and a salt.
//
// If salt is nil, a random salt is generated. The secret key is derived
// using the PBKDF2 algorithm with 100000 iterations, a key length of
// secretKeyLength and SHA-256 as the underlying hash function.
func deriveKey(passphrase string, salt []byte) ([]byte, []byte) {
	// Gernate a random salt if it is not provided
	if salt == nil {
		// Allocate space for the salt
		salt = make([]byte, saltLength)

		// Generate the salt randomly
		rand.Read(salt)
	}

	// Derive the secret key from the passphrase and salt
	key := pbkdf2.Key([]byte(passphrase), salt, 100000, secretKeyLength, sha256.New)

	return key, salt
}
